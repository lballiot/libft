
STRLCPY(3)               BSD Library Functions Manual               STRLCPY(3)

NNAAMMEE
     ssttrrllccppyy, ssttrrllccaatt -- size-bounded string copying and concatenation

LLIIBBRRAARRYY
     Standard C Library (libc, -lc)

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssttrriinngg..hh>>

     _s_i_z_e___t
     ssttrrllccppyy(_c_h_a_r _* _r_e_s_t_r_i_c_t _d_s_t, _c_o_n_s_t _c_h_a_r _* _r_e_s_t_r_i_c_t _s_r_c, _s_i_z_e___t _s_i_z_e);

     _s_i_z_e___t
     ssttrrllccaatt(_c_h_a_r _* _r_e_s_t_r_i_c_t _d_s_t, _c_o_n_s_t _c_h_a_r _* _r_e_s_t_r_i_c_t _s_r_c, _s_i_z_e___t _s_i_z_e);

DDEESSCCRRIIPPTTIIOONN
     The ssttrrllccppyy() and ssttrrllccaatt() functions copy and concatenate strings
     respectively.  They are designed to be safer, more consistent, and less
     error prone replacements for strncpy(3) and strncat(3).  Unlike those
     functions, ssttrrllccppyy() and ssttrrllccaatt() take the full size of the buffer (not
     just the length) and guarantee to NUL-terminate the result (as long as
     _s_i_z_e is larger than 0 or, in the case of ssttrrllccaatt(), as long as there is
     at least one byte free in _d_s_t).  Note that a byte for the NUL should be
     included in _s_i_z_e.  Also note that ssttrrllccppyy() and ssttrrllccaatt() only operate on
     true ``C'' strings.  This means that for ssttrrllccppyy() _s_r_c must be NUL-termi-
     nated and for ssttrrllccaatt() both _s_r_c and _d_s_t must be NUL-terminated.

     The ssttrrllccppyy() function copies up to _s_i_z_e - 1 characters from the NUL-ter-
     minated string _s_r_c to _d_s_t, NUL-terminating the result.

     The ssttrrllccaatt() function appends the NUL-terminated string _s_r_c to the end
     of _d_s_t.  It will append at most _s_i_z_e - strlen(dst) - 1 bytes, NUL-termi-
     nating the result.

     The source and destination strings should not overlap, as the behavior is
     undefined.

RREETTUURRNN VVAALLUUEESS
     The ssttrrllccppyy() and ssttrrllccaatt() functions return the total length of the
     string they tried to create.  For ssttrrllccppyy() that means the length of _s_r_c.
     For ssttrrllccaatt() that means the initial length of _d_s_t plus the length of
     _s_r_c.  While this may seem somewhat confusing, it was done to make trunca-
     tion detection simple.

     Note however, that if ssttrrllccaatt() traverses _s_i_z_e characters without finding
     a NUL, the length of the string is considered to be _s_i_z_e and the destina-
     tion string will not be NUL-terminated (since there was no space for the
     NUL).  This keeps ssttrrllccaatt() from running off the end of a string.  In
     practice this should not happen (as it means that either _s_i_z_e is incor-
     rect or that _d_s_t is not a proper ``C'' string).  The check exists to pre-
     vent potential security problems in incorrect code.

EEXXAAMMPPLLEESS
     The following code fragment illustrates the simple case:

           char *s, *p, buf[BUFSIZ];

           ...

           (void)strlcpy(buf, s, sizeof(buf));
           (void)strlcat(buf, p, sizeof(buf));

     To detect truncation, perhaps while building a pathname, something like
     the following might be used:

           char *dir, *file, pname[MAXPATHLEN];

           ...

           if (strlcpy(pname, dir, sizeof(pname)) >= sizeof(pname))
                   goto toolong;
           if (strlcat(pname, file, sizeof(pname)) >= sizeof(pname))
                   goto toolong;

     Since it is known how many characters were copied the first time, things
     can be sped up a bit by using a copy instead of an append

           char *dir, *file, pname[MAXPATHLEN];
           size_t n;

           ...

           n = strlcpy(pname, dir, sizeof(pname));
           if (n >= sizeof(pname))
                   goto toolong;
           if (strlcpy(pname + n, file, sizeof(pname) - n) >= sizeof(pname) - n)
                   goto toolong;

     However, one may question the validity of such optimizations, as they
     defeat the whole purpose of ssttrrllccppyy() and ssttrrllccaatt().  As a matter of
     fact, the first version of this manual page got it wrong.

SSEEEE AALLSSOO
     snprintf(3), strncat(3), strncpy(3), wcslcpy(3)

HHIISSTTOORRYY
     The ssttrrllccppyy() and ssttrrllccaatt() functions first appeared in OpenBSD 2.4, and
     made their appearance in FreeBSD 3.3.

BSD                              June 22, 1998                             BSD
